<section>
<section>

<h1>Desde la perspectiva de infraestructura</h1>

</section>
<section>

<h2>Desde la perspectiva de infraestructura</h2>

<ul>
<li>Se intenta capturar una configuración funcional que permita:

<ul>
<li>Replicar un ambiente</li>
<li>Recuperación ante desastres</li>
</ul>
</li>
<li>Surge la posibilidad de versionar la infraestructura

<ul>
<li>Esto implica poder repetir la instalación de un server</li>
</ul>
</li>
<li>Surgen nuevas necesidades:

<ul>
<li>Orden en cuanto al inicio de servicios</li>
<li>Cambios de plataformas de virtualización por costos o funcionalidad</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Herramientas</h2>

<ul>
<li>Gestión de las configuraciones usando Chef</li>
<li>Gestión de la infraestrcutura usando chef-provisioning</li>
<li>Docker en producción con Rancher</li>
</ul>

</section>
<section>

<p><img src="images/chef-white-logo.png" alt="Chef Logo"></p>

</section>
<section>

<h2>Chef</h2>

<ul>
<li>Chef permite modelar la evolución de nuestra infraestructura y aplicaciones como
si fueran código</li>
<li>No impone restricciones</li>
<li>Permite describir y automatizar los procesos e infraestructura</li>
<li>La consecuencia es que la infraestructura se vuelve:

<ul>
<li>Versionable</li>
<li>Testeable</li>
<li>Replicable</li>
<li>Idempotente</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Conceptos de chef</h2>

<ul>
<li>Para lograr su objetivo se utilizan definiciones reutilizables llamadas
<strong>cookbooks</strong> y <strong>recipes</strong>
</li>
<li>Se programa en Ruby usando una DSL</li>
</ul>

</section>
<section>

<h2>Arquitectura</h2>

<p><img alt="Chef architecture" src="images/chef-architecture.png" height="500"></p>

</section>
<section>

<h2>Entidades de chef</h2>

<ul>
<li>Roles</li>
<li>Nodos

<ul>
<li>Atributos</li>
</ul>
</li>
<li>Data Bags</li>
</ul>

<p>Además, es posible realizar búsquedas sobre estas entidades</p>

</section>
<section>

<h2>Ejemplo de una receta</h2>
<pre><code class="ruby">package 'nginx'

service 'nginx' do
  action [:enable, :start]
end

template '/etc/nginx/sites-enabled/www.conf' do
  source 'nginx-default.conf.erb'
  variables(
    server_name: 'www.mikroways.net',
    document_root: '/var/www'
  )
  notifies :restart, 'service[nginx]', :immediately
end
</code></pre>
<p><small class="fragment">
<a href="images/samples/04-chef/recipes/default.rb">Ver ejemplo completo</a>
<br>
<em>Es posible probar las recetas con una versión de chef llamada
chef-zero/chef-solo</em>
</small></p>

</section>
<section>

<h2>TDD</h2>

<ul>
<li>Ejemplo de <a href="images/samples/04-chef/spec/unit/recipes/web-server-test_spec.rb">test de unidad</a>

<ul>
<li>Basados en <a href="https://github.com/sethvargo/chefspec">ChefSpec</a>
</li>
<li><code>rspec</code></li>
<li><code>rubocop</code></li>
<li><code>foodcritic</code></li>
</ul>
</li>
<li>Ejemplo de <a href="images/samples/04-chef/test/integration/default/serverspec/integration-web-server_spec.rb">test de
integración</a>

<ul>
<li>Basados en <a href="http://kitchen.ci/">Test Kitchen</a>
</li>
<li>Probamos un test implementado con <a href="http://serverspec.org/">ServerSpec</a> en
plataformas Debian 7 y Ubuntu 14.04</li>
<li><code>kitchen</code></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Desplegando el potencial de chef</h2>

<ul>
<li>Bootstrap de nodos

<ul>
<li>Usaremos knife-ec2</li>
</ul>
</li>
<li>Búsquedas</li>
<li>Ambientes</li>
<li>ssh en paralelo</li>
<li>Búsquedas en recetas

<ul>
<li><em>Ejemplo con ha-proxy</em></li>
</ul>
</li>
</ul>

</section>
<section>

<h2>Bootstrap de nodos</h2>

<ul>
<li>Usaremos Amazon EC2 y un plugin de chef que simplifica y unifica las tareas de
crear y bootstrapear un nodo </li>
<li>Crearemos antes un rol que describe un web server. Esto nos permitirá realizar
búsquedas</li>
</ul>
<pre><code class="bash"># Crea/actualiza el rol web-server
knife role from file roles/web-server.rb
# Crea dos nodos llamados web-01 y web-02 en amazon con el rol
# web-server
knife ec2 server create -I ami-b1a652d1 -f m1.small --ssh-user ubuntu \
  -N web-01 -r 'role[web-server]'
knife ec2 server create -I ami-b1a652d1 -f m1.small --ssh-user ubuntu \
  -N web-02 -r 'role[web-server]'
## Listamos las instancias de Amazon EC2
knife ec2 server list
</code></pre>
<p><small>
<em><strong>Algunos detalles que se omiten se toman de la configuración de knife</strong></em>
</small></p>

</section>
<section>

<h2>Un poco de knife</h2>
<pre><code class="bash">knife status
knife role list
knife node list
knife search '*:*'
knife search 'platform:ubuntu AND (name:web-01 OR role:web-server)'
knife ssh -x ubuntu 'role:web-server' sudo service nginx stop
knife exec -E 'search(:node, "role:web-server").each do |node| 
  puts(
    node.name =&gt; {
      ip: node.cloud.public_ipv4,
      mem: node.memory.total,
      cpu: node.cpu.total
    }
  )
end'
</code></pre>
<p><small>
<em><strong>Lo interesante es que uno puede usar búsquedas en las recetas</strong></em>
</small></p>

</section>
<section>

<h2>Creamos un proxy reverso</h2>

<p><small>
<em><strong>Esta receta utiliza búsquedas para configurar los backends de haproxy</strong></em>
</small></p>
<pre><code class="ruby">all_web_servers = search(:node, "role:web-server")
members = []
all_web_servers.each do |web|
  members &lt;&lt;
  {
    "hostname"  =&gt; web['cloud']['public_hostname'],
    "ipaddress" =&gt; web['cloud']['public_ipv4'],
    "port"      =&gt; 80,
    "ssl_port"  =&gt; 80
  }
end
node.default['haproxy']['members'] = members

include_recipe 'haproxy'

</code></pre>
<pre><code class="bash">knife ec2 server create -I ami-b1a652d1 -f m1.small --ssh-user ubuntu \
  -N proxy -r 'recipe[myhaproxy]'
</code></pre>
<p><small>
Probar con <strong>curl</strong> y eliminar con
<br>
<code>knife ec2 server delete &lt;INSTANCE-ID&gt; -P</code>
</small></p>

</section>
<section>

<h2>Chef no es el único</h2>

<ul>
<li>Y... ¿por qué chef?</li>
<li>Hoy día Ansible es la alternativa más elegida</li>
<li>Puppet es la principal competencia</li>
</ul>

</section>
</section>

<section>
<section>

<h1>chef-provisioning</h1>

</section>
<section>

<h2>Introducción</h2>

<ul>
<li>Chef provisioning extiende chef permitiendo crear VMs en diferentes plataformas
de virtualización

<ul>
<li>Vagrant</li>
<li>AWS</li>
<li>Azure</li>
<li>DigitalOcean</li>
<li>VMWare</li>
<li>XenServer</li>
<li>Google Compute Engine</li>
<li>IBM SoftLayer</li>
<li>Y varios más</li>
</ul>
</li>
</ul>

</section>
<section>

<h2>¿Qué es entonces?</h2>

<ul>
<li>Permite configurar nuestro cluster de máquinas de forma agnóstica de la
plataforma</li>
<li>Evita el uso reiterativo de knife para iniciar VMs </li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>
<pre><code class="ruby">chef_role 'web-server' do
  run_list ["recipe[apt]","recipe[web-server]"]
end

machine_batch do
  machine 'web-01' do
    run_list ['role[web-server]']
  end
  machine 'web-02' do
    run_list ['role[web-server]']
  end
end

machine 'proxy' do
  run_list ['recipe[myhaproxy]']
end

</code></pre>
<p><em><strong>Corremos en nuestra PC</strong></em></p>
<pre><code class="bash">chef-client -z -r 'my-infra::chef,my-infra::aws,my-infra'
</code></pre>
</section>
<section>

<h2>Eliminando todo</h2>
<pre><code class="ruby">chef_role 'web-server' do
  action :delete
end

machine_batch do
  action :destroy
  machines 'web-01', 'web-02', 'proxy'
end
</code></pre>
<p><em><strong>Corremos en nuestra PC</strong></em></p>
<pre><code class="bash">chef-client -z -r 'my-infra::chef,my-infra::aws,my-infra::delete'
</code></pre>
</section>
<section>

<h2>Y ahora con Vagrant</h2>
<pre><code class="bash">
chef-client -z -r 'my-infra::chef,my-infra::vagrant,my-infra'

</code></pre>
<p>Esto es muy importante, porque sólo cambiando el driver de aprovisionamiento,
podemos reusar nuestra infraestructura definida</p>

<p><small class="fragment">
Podemos incluso tener un cluster con VMs de diferentes proveedores
</small></p>

</section>
<section>

<h2>Terraform</h2>

<p><a href="https://www.terraform.io/">
<img alt="Terraform logo" src="images/terraform-logo.png" height="300px">
</a></p>

<p><em><strong>La alternativa a chef-provisioning</strong></em></p>

</section>
</section>

<section>
<section>

<h1>Clusters de contenedores</h1>

<p><img src="images/docker-cluster.png" height="350"></p>

</section>
<section>

<h2>Alternativas en boga</h2>

<ul>
<li><a href="https://docs.docker.com/swarm/">Docker Swarm</a></li>
<li><a href="http://rancher.com/">Rancher Cattle</a></li>
<li><a href="http://kubernetes.io/">Kubernetes</a></li>
<li><a href="http://mesos.apache.org/">Mesos</a></li>
</ul>

</section>
<section>

<h2>Además se habla mucho de</h2>

<ul>
<li><a href="http://rancher.com/rancher-os/">Rancher OS</a></li>
<li><a href="https://coreos.com/">CoreOS</a></li>
<li><a href="http://boot2docker.io/">Boot2docker</a></li>
</ul>

</section>
<section>

<h2>Características</h2>

<ul>
<li>Schedulling de contenedores

<ul>
<li>Importancia de los labels en docker</li>
</ul>
</li>
<li>Service discovery

<ul>
<li>Zookeper</li>
<li>Consul</li>
<li>Etcd</li>
</ul>
</li>
<li>Complicaciones:

<ul>
<li>Volúmenes compartidos</li>
<li>Monitoreo y Logs</li>
</ul>
</li>
</ul>

</section>
<section>

<h1>Rancher</h1>

</section>
<section>

<h2>Rancher</h2>

<ul>
<li>Permite configurar ambientes

<ul>
<li>Con Cattle, Swarm, Kubernetes y ahora Mesos</li>
</ul>
</li>
<li>Los ambientes se componen de nodos</li>
<li>Los contenedores se manejan con stacks

<ul>
<li>Usan docker-compose v1</li>
<li>Provee un catálogo de aplicaciones</li>
<li>Permite extender el catálogo con uno propio</li>
</ul>
</li>
<li>Simplifica la integración con registries privadas</li>
<li>Proxy reverso basado en service discovery</li>
<li>Simple escalamiento de contenedores</li>
</ul>

</section>
<section>

<h2>Ejemplo</h2>

<ul>
<li>Deployamos un wordpress desde el catálogo

<ul>
<li>Fijamos que sólo corra la db en un nodo determinado</li>
</ul>
</li>
<li>Escalamos el servicio</li>
</ul>

</section>
<section>

<h2>Otro ejemplo</h2>

<ul>
<li>Creamos una aplicacion propia

<ul>
<li>El nombre del directorio es importante: nombre del stack</li>
<li>Creamos
<a href="images/samples/07-rancher/my-custom-app/docker-compose.yml"><code>docker-compose.yml</code></a>
</li>
<li>Iniciamos el stack: <code>rancher-compose up</code>
</li>
<li><em>Verificamos</em></li>
<li>Upgradeamos: <code>rancher-compose up -u my-app</code>
</li>
<li><em>Verificamos</em></li>
<li>Realizamos un rollback</li>
</ul>
</li>
</ul>

</section>
</section>
